/*
 ============================================================================
 Name        : svd_sym.c
 Author      : Daniel Mårtensson
 Version     : 1.0
 Copyright   : MIT
 Description : Do singular value decomposition on a symmetric matrix A by using LAPACK subroutine
 ============================================================================
 */

#include "CControl/ccontrol.h"

#define row 500

int main() {

	/* Matrix A */
	float* A = (float*)malloc(row * row * sizeof(float));
	float* B = (float*)malloc(row * row * sizeof(float));
	float* C = (float*)malloc(row * row * sizeof(float));

	/* Turn C symmetric */
	randn(A, row * row, 0, 1);
	memcpy(B, A, row * row * sizeof(float));
	tran(B, row, row);
	mul(A, B, C, row, row, row);

	/* Print symmetric matrix C */
	if (row < 10) {
		print(C, row, row);
	}

	/* Create eigenvector and eigenvalues matrices */
	float* U = (float*)malloc(row * row * sizeof(float));
	float* S = (float*)malloc(row * sizeof(float));
	float* V = (float*)malloc(row * row * sizeof(float));

	/* Do SVD with LAPACK routine */
	clock_t start, end;
	float cpu_time_used;
	start = clock();
	printf("Begin SVD\n");
	bool status = svd_sym(C, row, U, S, V);
	end = clock();
	cpu_time_used = ((float)(end - start)) / CLOCKS_PER_SEC;
	printf("\nTotal speed  was %f\n", cpu_time_used);

	/* Print matrices */
	if (row < 10) {
		/* Print U */
		printf("U\n");
		print(U, row, row);

		/* Print U */
		printf("S\n");
		print(S, row, 1);

		/* Print V */
		printf("V\n");
		print(V, row, row);
	}

	/* Is computed correctly */
	printf("Found solution: %s\n", status ? "yes" : "no");

	/* Free */
	free(A);
	free(B);
	free(C);
	free(U);
	free(S);
	free(V);

	return EXIT_SUCCESS;
}

/*
 * GNU Octave code:
 * A = [0.453690,   0.866686,   0.579250,   0.418100,
		0.059901,   0.954740,   0.699338,   0.681427,
		0.127995,   0.981347,   0.713651,   0.485167,
		0.269875,   0.723569,   0.778578,   0.130682];

   [U, S, V] = svd(A)
 */
