/*
 ============================================================================
 Name        : sr_ukf_state_estimation.c
 Author      : Daniel MÃ¥rtensson
 Version     : 1.0
 Copyright   : MIT
 Description : Filter with Square Root Unscented Kalman Filter
 ============================================================================
 */

#include "CControl/Headers/Functions.h"

int main() {

	/*
	 * Hello! This is Square Root Uncented Kalman Filter (SR-UKF) and this algorithm is successor of Uncented Kalman Filter(UKF)
	 * because UKF had some issues with the cholesky decomposition when it going to find the square root.
	 * SR-UKF come in two papers. The first paper and the second paper. The first paper does not re-compute sigma point matrix for the
	 * observability function H. The second paper re-compute sigma point matrix for the observability function H.
	 * In this algorithm, I assume that the output y and the state has the same dimension and observability function is just an identity matrix.
	 * That's because I want to minimize the input arguments for the SR-UKF function. Less turning parameters, function, constants and so on makes
	 * it easier to use SR-UKF.
	 */

	/* Initial parameters */
	uint8_t L = 3; 																// How many states we have
	float r = 0.1f;																// Tuning factor for noise
	float q = 0.1f;																// Tuning factor for disturbance
	float alpha = 0.01f; 														// Alpha value - A small number like 0.01 -> 1.0
	float beta = 2; 															// Beta value - Normally 2 for gaussian noise
	float kappa = 0; 															// Kappa value - Normally 0 or L - 3 for parameter estimation(that's another algorithm)
	float Rv[3 * 3] = {q, 0, 0, 0, q, 0, 0, 0, q}; 								// Initial disturbance covariance matrix - Recommended to use identity matrix
	float Rn[3 * 3] = {r, 0, 0, 0, r, 0, 0, 0, r}; 								// Initial noise covariance matrix - Recommended to use identity matrix
	float S[3 * 3] = {1, 0, 0, 0, 1, 0, 0, 0, 1}; 								// Initial covariance matrix - Recommended to use identity matrix
	float xhat[3] = {0, 0, 0}; 													// Estimated state vector
	float y[3] = {0, 0, 0};														// This is our measurement
	float u[3] = {0, 0, 0}; 													// u is not used in this example due to the transition function not using an input signal
	float x[3] = {0, 0, 1};														// State vector for the system (unknown in reality)

	/* Our transition function */
	void F(float dx[], float x[], float u[]) {
		dx[0] = x[1];
		dx[1] = x[2];
		dx[2] = 0.05*x[0]*(x[1] + x[2]);
	}

	clock_t start, end;
	float cpu_time_used;
	start = clock();

	/* Do SR-UKF */
	float X[100*3];
	float XHAT[100*3];
	float noise[3];
	float dx[3];
	for (uint32_t i = 0; i < 100; i++) {
		/* Create measurement */
		randn(noise, L, 1.0f, 1.0f);
		for(uint8_t j = 0; j < L; j++)
			y[j] = x[j] + r*noise[j];

		/* Save actual state */
		for(uint8_t j = 0; j < L; j++)
			X[i*3 + j] = x[j];

		/* Estimate new state */
		sr_ukf_state_estimation(y, xhat, Rn, Rv, u, F, S, alpha, beta, kappa, L);

		/* Save the estimated state */
		for(uint8_t j = 0; j < L; j++)
			XHAT[i*3 + j] = xhat[j];

		/* Update process */
		F(dx, x, u);
		randn(noise, L, 0.0f, 1.0f);
		for(uint8_t j = 0; j < L; j++)
			x[j] = dx[j] + q*noise[j];

	}

	end = clock();
	cpu_time_used = ((float) (end - start)) / CLOCKS_PER_SEC;
	printf("\nTotal speed  was %f\n", cpu_time_used);

	// Here is the filtered data
	printf("Actual state\n");
	print(X, 100, 3);

	printf("Estimated state\n");
	print(XHAT, 100, 3);

	return EXIT_SUCCESS;
}